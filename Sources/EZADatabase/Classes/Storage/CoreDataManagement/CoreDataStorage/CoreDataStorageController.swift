//
//  CoreDataStorageController.swift
//  TempProject
//
//  Created Eugene Software on 11/12/21.
//  Copyright Â© 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file is generated by custom SKELETON Xcode template.
//

import Foundation
import CoreData

class FrameworkPersistentContainer: NSPersistentContainer {}

private extension DispatchQueue {
    static var coreDataConcurrent: DispatchQueue = DispatchQueue(label: UUID().uuidString, qos: .userInitiated, attributes: .concurrent)
}

class CoreDataStorageController: NSObject {
    
    private static let kEZADatabaseModelName = "EZADatabaseModelName";
    
    //Static Properties
    //
    static var shared: CoreDataStorageInterface = {
        return CoreDataStorageController(completionClosure: nil)
    }()
    
    //Private Properties
    //
    private var persistentContainer: NSPersistentContainer!
    private var backgroundContext: NSManagedObjectContext?
    
    //Public Properties
    //
    var viewContext: NSManagedObjectContext {
        return persistentContainer.viewContext
    }
    
    init(completionClosure: (() -> Void)?) {
        
        super.init()
        loadStore(completionClosure: completionClosure)
    }
    
    func loadStore(completionClosure: (() -> Void)?) {
        
        guard let containerName = Bundle.main.infoDictionary?[Self.kEZADatabaseModelName] as? String else {
            fatalError("EZADatabaseModelName should be specified in Info.plist. Make sure it's equal to .xcdatamodel file name")
        }
        
        persistentContainer = FrameworkPersistentContainer(name: containerName)
        persistentContainer.loadPersistentStores() { (description, error) in
            
            if let error = error {
                print("Failed to load Core Data stack: \(error)")
            }
            
            completionClosure?()
        }
        
        // Initialize background context to perform all operations in background.
        //
        backgroundContext = persistentContainer.newBackgroundContext()
        backgroundContext?.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
        backgroundContext?.automaticallyMergesChangesFromParent = true
        persistentContainer.viewContext.automaticallyMergesChangesFromParent = true
        persistentContainer.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy
    }
}


//MARK: - DataStorageInterface

extension CoreDataStorageController: CoreDataStorageInterface {
    
    func deleteAllTables(except names: [String], completion: (() -> Void)?) {
        
        let context = backgroundContext
        let allEntitiyNames = persistentContainer.managedObjectModel.entities.compactMap { $0.name }
        let toBeRemoved = allEntitiyNames.filter { !names.contains($0) }
        
        save {
            do {
                for name in toBeRemoved {
                    let fetchRequest: NSFetchRequest<NSFetchRequestResult> = NSFetchRequest(entityName: name)
                    let deleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest)
                    try context?.executeAndMergeChanges(using: deleteRequest)
                }
            } catch {
                print(error)
            }
        } completionBlock: {
            completion?()
        }
    }
    
    func setValues<Type: CoreDataCompatible>(type: Type.Type, values: [String: Any?], predicate: NSPredicate?, completion: @escaping () -> Void) {
        
        let context = backgroundContext
        
        let entityName = String(describing: Type.ManagedType.self)
        let fetchRequest = NSFetchRequest<Type.ManagedType>(entityName: entityName)
        fetchRequest.predicate = predicate
        
        save {
            let result = context?.safeFetch(fetchRequest)
            result?.forEach({ (obj) in
                
                values.forEach { (key, value) in
                    
                    let old = obj.value(forKey: key)
                    let oldString = String(describing: old)
                    let newString = String(describing: value)
                    
                    if oldString != newString {
                        obj.setValue(value, forKeyPath: key)
                    } else {
                        print("Old: \(oldString), New: \(newString)")
                    }
                }
            })
        } completionBlock: {
            completion()
        }
    }
    
    func findRelation<Type: CoreDataExportable>(predicate: NSPredicate?) -> Type? {
        let result: Type? = query(predicate: predicate, context: backgroundContext!, sortDescriptors: nil, fetchLimit: 1)?.first
        return result
    }
    
    func insertSync<Type: CoreDataCompatible>(object: Type?, predicate: NSPredicate?) -> Type.ManagedType? {
        
        guard let object = object else { return nil }
        let predicate = predicate ?? NSPredicate(key: object.primaryKeyName, value: object.primaryKey)
        return self.insert(object: object, predicate: predicate, context: self.backgroundContext!)
    }
    
    func fetchedResultsProvider<Type: CoreDataCompatible>(mainPredicate: NSPredicate,
                                                          optionalPredicates: [NSPredicate]?,
                                                          sorting sortDescriptors: [NSSortDescriptor],
                                                          sectionName: String?,
                                                          fetchLimit: Int?) -> FetchedResultsProvider<Type>
    {
        return FetchedResultsProvider<Type>(mainPredicate,
                                            optionalPredicates: optionalPredicates,
                                            sorting: sortDescriptors,
                                            context: viewContext,
                                            sectionName: sectionName,
                                            fetchLimit: fetchLimit)
    }
    
    func insertList<Type: CoreDataCompatible>(objects: [Type?], completion: @escaping () -> Void) {
        
        let objects = objects.compactMap {$0}
        
        save {
            objects.forEach {
                let predicate = NSPredicate(key: $0.primaryKeyName, value: $0.primaryKey)
                self.insert(object: $0, predicate: predicate, context: self.backgroundContext!)
            }
        } completionBlock: {
            completion()
        }
    }
    
    func insertAsync<Type: CoreDataCompatible>(object: Type?, predicate: NSPredicate?, completion: @escaping () -> Void) {
        
        guard let object = object else {
            completion()
            return
        }
        save {
            let predicate = predicate ?? NSPredicate(key: object.primaryKeyName, value: object.primaryKey)
            self.insert(object: object, predicate: predicate, context: self.backgroundContext!)
        } completionBlock: {
            completion()
        }
    }
    
    func list<Type: CoreDataExportable>(predicate: NSPredicate?,
                                         sortDescriptors: [NSSortDescriptor]?,
                                         fetchLimit: Int?) -> [Type]? {
        return query(predicate: predicate, context: viewContext, sortDescriptors: sortDescriptors, fetchLimit: fetchLimit)
    }
    
    func asyncList<Type: CoreDataExportable>(predicate: NSPredicate?,
                                              sortDescriptors: [NSSortDescriptor]?,
                                              fetchLimit: Int?,
                                              completion: @escaping ([Type]?) -> Void) {
        
        let context = backgroundContext
        
        context?.perform { [weak self] in
            let result: [Type]? = self?.query(predicate: predicate, context: context!, sortDescriptors: sortDescriptors, fetchLimit: fetchLimit)
            completion(result)
        }
    }
    
    func delete<Type: CoreDataExportable>(_ type: Type.Type, with predicate: NSPredicate?, completion: @escaping () -> Void) {
        
        let context = backgroundContext
        
        let entityName = String(describing: Type.self)
        let fetchRequest = NSFetchRequest<Type>(entityName: entityName)
        fetchRequest.predicate = predicate
        
        save {
            if let result = context?.safeFetch(fetchRequest), !result.isEmpty {
                result.forEach { (obj) in
                    context?.delete(obj)
                }
            }
        } completionBlock: {
            completion()
        }
    }
    
    func compute<Type: CoreDataExportable>(_ type: Type.Type, operation: String, keyPath: String, predicate: NSPredicate?) -> Int? {
        
        let context = viewContext
        let entityName = String(describing: Type.self)
        let fetchRequest = NSFetchRequest<NSDictionary>(entityName: entityName)
        
        fetchRequest.predicate = predicate
        fetchRequest.resultType = .dictionaryResultType
        
        let averageExpressionDesc = NSExpressionDescription()
        averageExpressionDesc.name = operation
        
        let specialAvgExp = NSExpression(forKeyPath: keyPath)
        averageExpressionDesc.expression = NSExpression(forFunction: operation, arguments: [specialAvgExp])
        averageExpressionDesc.expressionResultType = .integer64AttributeType
        
        fetchRequest.propertiesToFetch = [averageExpressionDesc]
        let result = context.safeFetch(fetchRequest)
        return result?.first?[operation] as? Int
    }
}


//MARK: - Private methods

private extension CoreDataStorageController {
    
    func save(saveBlock: @escaping () -> Void, completionBlock: @escaping () -> Void) {
        
        let context = backgroundContext
        
        context?.perform { [weak context] in
            saveBlock()
            context?.saveSelfAndParent() {
                DispatchQueue.main.async {
                    completionBlock()
                }
            }
        }
    }
    
    @discardableResult
    func insert<Type: CoreDataCompatible>(object: Type?, predicate: NSPredicate?, context: NSManagedObjectContext) -> Type.ManagedType? {
        
        let entityName = String(describing: Type.ManagedType.self)
        let result: Type.ManagedType?
        
        if let list: [Type.ManagedType] = query(predicate: predicate, context: context, fetchLimit: nil), !list.isEmpty {
            result = list.first
        } else {
            result = NSEntityDescription.insertNewObject(forEntityName: entityName, into: context) as? Type.ManagedType
        }
        result?.configure(with: object as! Type.ManagedType.ExportType, in: self)
        return result
    }
    
    func query<Type: NSManagedObject>(predicate: NSPredicate?, context: NSManagedObjectContext, sortDescriptors: [NSSortDescriptor]? = nil, fetchLimit: Int? = nil) -> [Type]? {
        
        // Fetch entity with appropriate class
        //
        let entityName = String(describing: Type.self)
        let fetchRequest = NSFetchRequest<Type>(entityName: entityName)
        fetchRequest.sortDescriptors = sortDescriptors
        fetchRequest.predicate = predicate
        
        if let limit = fetchLimit {
            fetchRequest.fetchLimit = limit
        }
        
        return context.safeFetch(fetchRequest)
    }
}


//MARK: Convenience saving context
//
private extension NSManagedObjectContext {
    
    func safeFetch<T>(_ request: NSFetchRequest<T>) -> [T]? where T : NSFetchRequestResult {
        
        do {
            return try fetch(request)
        }
        catch {
            return nil
        }
    }
    func saveContextInstantly() {
        
        // Nothing to save
        //
        if !self.hasChanges { return }
        
        do {
            try save()
        } catch {
//            Crashlytics.crashlytics().record(error: error)
            fatalError("Error  saving context: \(error)")
        }
    }
    
    func saveSelfAndParent(completion: (() -> Void)?) {
        saveContextInstantly()
        
        if (parent != nil) {
            parent?.perform({[weak self] in
                self?.parent?.saveSelfAndParent(completion: completion)
            })
        } else {
            completion?()
        }
    }
}

private extension NSManagedObjectContext {
    
    /// Executes the given `NSBatchDeleteRequest` and directly merges the changes to bring the given managed object context up to date.
    ///
    /// - Parameter batchDeleteRequest: The `NSBatchDeleteRequest` to execute.
    /// - Throws: An error if anything went wrong executing the batch deletion.
    func executeAndMergeChanges(using batchDeleteRequest: NSBatchDeleteRequest) throws {
        
        batchDeleteRequest.resultType = .resultTypeObjectIDs
        let result = try execute(batchDeleteRequest) as? NSBatchDeleteResult
        let changes: [AnyHashable: Any] = [NSDeletedObjectsKey: result?.result as? [NSManagedObjectID] ?? []]
        NSManagedObjectContext.mergeChanges(fromRemoteContextSave: changes, into: [self])
    }
}

